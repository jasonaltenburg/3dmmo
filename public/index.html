<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D MMO RPG</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      z-index: 9999;
    }
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #player-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
    #gold-display {
      color: gold;
      font-weight: bold;
    }
    #inventory-button {
      position: absolute;
      bottom: 170px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid #555;
      pointer-events: auto;
    }
    #inventory-panel {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      height: 400px;
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 20px;
      border-radius: 5px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      pointer-events: auto;
    }
    #inventory-tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 1px solid #555;
    }
    .inventory-tab {
      padding: 8px 15px;
      margin-right: 5px;
      cursor: pointer;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    .inventory-tab.active {
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #555;
      border-bottom: none;
    }
    .inventory-content {
      display: none;
      height: 320px;
      overflow-y: auto;
    }
    .inventory-content.active {
      display: block;
    }
    .inventory-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 3px;
      background-color: rgba(255, 255, 255, 0.1);
    }
    .item-common {
      border-left: 3px solid white;
    }
    .item-rare {
      border-left: 3px solid #4444ff;
    }
    .item-epic {
      border-left: 3px solid #aa44ff;
    }
    .item-name {
      flex: 2;
    }
    .item-stats {
      flex: 2;
      color: #aaa;
    }
    .item-action {
      flex: 1;
      text-align: right;
    }
    .item-action button {
      padding: 3px 8px;
      background-color: #555;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    .item-action button:hover {
      background-color: #777;
    }
    #shop-panel {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 600px;
      height: 400px;
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 20px;
      border-radius: 5px;
      font-size: 14px;
      display: none;
      z-index: 1000;
      pointer-events: auto;
    }
    #shop-tabs {
      display: flex;
      margin-bottom: 15px;
      border-bottom: 1px solid #555;
    }
    .shop-tab {
      padding: 8px 15px;
      margin-right: 5px;
      cursor: pointer;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
    }
    .shop-tab.active {
      background-color: rgba(255, 255, 255, 0.2);
      border: 1px solid #555;
      border-bottom: none;
    }
    .shop-content {
      display: none;
      height: 320px;
      overflow-y: auto;
    }
    .shop-content.active {
      display: block;
    }
    .shop-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      margin-bottom: 5px;
      border-radius: 3px;
      background-color: rgba(255, 255, 255, 0.1);
    }
    .shop-item-price {
      color: gold;
      font-weight: bold;
    }
    #buff-icons {
      position: absolute;
      top: 170px;
      left: 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .buff-icon {
      width: 40px;
      height: 40px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      position: relative;
    }
    .buff-icon img {
      width: 24px;
      height: 24px;
    }
    .buff-timer {
      position: absolute;
      bottom: 2px;
      font-size: 9px;
    }
    .glow-effect {
      animation: glow 2s infinite alternate;
    }
    @keyframes glow {
      from {
        box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #e60073, 0 0 20px #e60073;
      }
      to {
        box-shadow: 0 0 10px #fff, 0 0 15px #ff4da6, 0 0 20px #ff4da6, 0 0 25px #ff4da6;
      }
    }
    #region-info {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
    #combat-log {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 250px;
      height: 150px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      overflow-y: auto;
    }
    #minimap {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 150px;
      height: 150px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 5px;
      padding: 5px;
    }
    .health-bar-container {
      width: 100%;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
      margin: 5px 0;
      overflow: hidden;
    }
    .health-bar {
      height: 100%;
      background-color: #00cc00;
      transition: width 0.3s, background-color 0.3s;
    }
    .xp-bar-container {
      width: 100%;
      height: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
      margin: 5px 0;
      overflow: hidden;
    }
    .xp-bar {
      height: 100%;
      background-color: #9933ff;
      transition: width 0.3s;
      width: 0%;
    }
  </style>
</head>
<body>
  <div id="loading">Loading game...</div>
  
  <div id="ui">
    <div id="player-info">
      <div>Level: <span id="player-level">1</span></div>
      <div>Health: <span id="player-health">100</span>/<span id="player-max-health">100</span></div>
      <div class="health-bar-container">
        <div class="health-bar" id="health-bar"></div>
      </div>
      <div>XP: <span id="player-xp">0</span>/<span id="player-max-xp">100</span></div>
      <div class="xp-bar-container">
        <div class="xp-bar" id="xp-bar"></div>
      </div>
      <div>Gold: <span id="gold-display">0</span></div>
    </div>
    
    <button id="inventory-button">Inventory (I)</button>
    
    <div id="buff-icons">
      <!-- Buff icons will be added here dynamically -->
    </div>
    
    <div id="region-info" style="opacity: 0;">
      <h3 id="region-name">Unknown Region</h3>
      <div id="region-description"></div>
    </div>
    
    <div id="minimap">
      <canvas id="minimap-canvas" width="150" height="150"></canvas>
    </div>
    
    <div id="combat-log"></div>
    
    <!-- Inventory Panel -->
    <div id="inventory-panel">
      <h2>Inventory</h2>
      <div id="inventory-tabs">
        <div class="inventory-tab active" data-tab="equipment">Equipment</div>
        <div class="inventory-tab" data-tab="consumables">Consumables</div>
      </div>
      
      <div id="equipment-tab" class="inventory-content active">
        <!-- Equipment items will be added here -->
      </div>
      
      <div id="consumables-tab" class="inventory-content">
        <!-- Consumable items will be added here -->
      </div>
      
      <button id="close-inventory" style="position: absolute; top: 10px; right: 10px;">X</button>
    </div>
    
    <!-- Shop Panel -->
    <div id="shop-panel">
      <h2 id="shop-title">Shop</h2>
      <div id="shop-tabs">
        <div class="shop-tab active" data-tab="weapons">Weapons</div>
        <div class="shop-tab" data-tab="armor">Armor</div>
        <div class="shop-tab" data-tab="consumables">Consumables</div>
      </div>
      
      <div id="weapons-tab" class="shop-content active">
        <!-- Weapon items will be added here -->
      </div>
      
      <div id="armor-tab" class="shop-content">
        <!-- Armor items will be added here -->
      </div>
      
      <div id="consumables-tab" class="shop-content">
        <!-- Consumable items will be added here -->
      </div>
      
      <button id="close-shop" style="position: absolute; top: 10px; right: 10px;">X</button>
    </div>
  </div>
  
  <!-- Import external libraries -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  
  <script>
    // Initialize socket.io connection
    const socket = io();
    
    // Display loading message
    function updateLoadingMessage(message) {
      const loadingElement = document.getElementById('loading');
      loadingElement.innerHTML = message;
      console.log(message);
    }
    
    // Error handler
    function handleError(error) {
      console.error('Error:', error);
      updateLoadingMessage('Error loading game: ' + error.message + '<br>Check browser console for details.');
    }
    
    // Game variables
    let scene, camera, renderer, controls;
    let player, otherPlayers = {};
    let ground, world = {};
    let enemies = [];
    let activeRegion = null;
    
    // Movement and input
    const keys = {
      KeyW: false,
      KeyA: false,
      KeyS: false,
      KeyD: false,
      Space: false
    };
    
    // Player stats
    const playerStats = {
      level: 1,
      health: 100,
      maxHealth: 100,
      experience: 0,
      experienceToNextLevel: 100,
      attackDamage: 10,
      defense: 5
    };
    
    // Game regions
    const regions = [
      {
        name: 'Town',
        position: new THREE.Vector3(0, 0, 0),
        radius: 10,
        type: 'safe',
        color: 0x999999
      },
      {
        name: 'Cemetery',
        position: new THREE.Vector3(0, 0, -40),
        radius: 25,
        type: 'combat',
        enemyType: 'skeleton',
        enemyLevel: 1,
        maxEnemies: 5,
        color: 0x666666
      },
      {
        name: 'Cave',
        position: new THREE.Vector3(40, 0, 0),
        radius: 25,
        type: 'combat',
        enemyType: 'bat',
        enemyLevel: 2,
        maxEnemies: 5,
        color: 0x8b4513
      },
      {
        name: 'Field',
        position: new THREE.Vector3(0, 0, 40),
        radius: 25,
        type: 'combat',
        enemyType: 'snake',
        enemyLevel: 3,
        maxEnemies: 5,
        color: 0xc2b280
      },
      {
        name: 'Castle',
        position: new THREE.Vector3(-40, 0, 0),
        radius: 25,
        type: 'combat',
        enemyType: 'vampire',
        enemyLevel: 5,
        maxEnemies: 5,
        color: 0x555555
      }
    ];
    
    // Setup game
    function initGame() {
      try {
        updateLoadingMessage('Setting up 3D world...');
        setupScene();
        setupPlayer();
        setupWorld();
        setupEventListeners();
        setupUI();
        
        // Start animation loop
        animate();
        
        // Hide loading screen
        document.getElementById('loading').style.display = 'none';
        console.log('Game initialized successfully!');
        
        // Add welcome message
        addCombatMessage('Welcome to 3D MMO! Use WASD to move, SPACE to attack, and mouse to look around.');
      } catch (error) {
        handleError(error);
      }
    }
    
    // Setup 3D scene
    function setupScene() {
      // Create scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // Sky blue
      
      // Create camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 10);
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Setup lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // Create controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below ground
      controls.minDistance = 5;
      controls.maxDistance = 15;
      controls.enableDamping = true;
      controls.dampingFactor = 0.1;
      controls.rotateSpeed = 0.5;
      controls.target.set(0, 1, 0);
      controls.update();
    }
    
    // Setup player
    function setupPlayer() {
      // Create player group
      player = new THREE.Group();
      
      // Player body
      const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x3366ff,
        roughness: 0.7,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.9;
      body.castShadow = true;
      body.receiveShadow = true;
      player.add(body);
      
      // Player head
      const headGeometry = new THREE.SphereGeometry(0.35, 8, 8);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xffddbb,
        roughness: 0.7,
        metalness: 0.1
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.75;
      head.castShadow = true;
      head.receiveShadow = true;
      player.add(head);
      
      // Arms
      const armGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.2);
      
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
      leftArm.position.set(-0.4, 0.95, 0);
      leftArm.castShadow = true;
      leftArm.receiveShadow = true;
      player.add(leftArm);
      player.leftArm = leftArm;
      
      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
      rightArm.position.set(0.4, 0.95, 0);
      rightArm.castShadow = true;
      rightArm.receiveShadow = true;
      player.add(rightArm);
      player.rightArm = rightArm;
      
      // Legs
      const legGeometry = new THREE.BoxGeometry(0.25, 0.8, 0.25);
      
      const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      leftLeg.position.set(-0.2, 0.4, 0);
      leftLeg.castShadow = true;
      leftLeg.receiveShadow = true;
      player.add(leftLeg);
      player.leftLeg = leftLeg;
      
      const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      rightLeg.position.set(0.2, 0.4, 0);
      rightLeg.castShadow = true;
      rightLeg.receiveShadow = true;
      player.add(rightLeg);
      player.rightLeg = rightLeg;
      
      // Sword (only visible during attack)
      const swordGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
      const swordMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.3,
        metalness: 0.8
      });
      const sword = new THREE.Mesh(swordGeometry, swordMaterial);
      sword.position.set(0, 0.4, 0);
      
      // Sword handle
      const handleGeometry = new THREE.BoxGeometry(0.15, 0.2, 0.15);
      const handleMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        roughness: 0.8,
        metalness: 0.2
      });
      const handle = new THREE.Mesh(handleGeometry, handleMaterial);
      handle.position.y = -0.45;
      sword.add(handle);
      
      // Add sword to right arm
      rightArm.add(sword);
      player.sword = sword;
      
      // Initially hide sword
      sword.visible = false;
      
      // Add player to scene
      scene.add(player);
      
      // Set initial position
      player.position.set(0, 0, 0);
      
      // Setup attack cooldown
      player.attackCooldown = 0;
      player.maxAttackCooldown = 30; // frames (at 60fps = 0.5 seconds)
    }
    
    // Setup world
    function setupWorld() {
      // Basic world setup - central ground
      const worldSize = 200;
      const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
      const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x33aa33,
        roughness: 0.8,
        metalness: 0.2
      });
      ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Create regions
      regions.forEach(region => {
        // Create region ground
        const regionGeometry = new THREE.CircleGeometry(region.radius, 32);
        const regionMaterial = new THREE.MeshStandardMaterial({ 
          color: region.color,
          roughness: 0.8,
          metalness: 0.2
        });
        const regionMesh = new THREE.Mesh(regionGeometry, regionMaterial);
        regionMesh.rotation.x = -Math.PI / 2;
        regionMesh.position.copy(region.position);
        regionMesh.position.y = 0.01; // Slightly above to prevent z-fighting
        regionMesh.receiveShadow = true;
        scene.add(regionMesh);
        
        // Add region info text
        if (region.name === 'Town') {
          addTownBuildings(region);
        }
      });
      
      // Update initial region
      checkPlayerRegion();
    }
    
    // Add town buildings
    function addTownBuildings(region) {
      const buildingPositions = [
        { x: -5, z: -5 },
        { x: 5, z: -5 },
        { x: -5, z: 5 },
        { x: 5, z: 5 },
        { x: 0, z: 0 }, // Center building
      ];
      
      buildingPositions.forEach((pos, index) => {
        const isCenter = index === buildingPositions.length - 1;
        const size = isCenter ? 4 : 3;
        const height = isCenter ? 5 : 3;
        
        // Building base
        const buildingGeometry = new THREE.BoxGeometry(size, height, size);
        const buildingMaterial = new THREE.MeshStandardMaterial({ 
          color: isCenter ? 0x8b4513 : 0xd2b48c,
          roughness: 0.8,
          metalness: 0.2
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.set(region.position.x + pos.x, height / 2, region.position.z + pos.z);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
        
        // Roof
        const roofGeometry = new THREE.ConeGeometry(size * 0.8, height / 2, 4);
        const roofMaterial = new THREE.MeshStandardMaterial({ 
          color: isCenter ? 0x800000 : 0xa52a2a,
          roughness: 0.7,
          metalness: 0.1
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.set(0, height / 2 + height / 4, 0);
        roof.castShadow = true;
        roof.rotation.y = Math.PI / 4; // Rotate 45 degrees to align with building
        building.add(roof);
      });
    }
    
    // Create enemy by type
    function createEnemy(type, level, position) {
      const enemy = new THREE.Group();
      enemy.position.copy(position);
      enemy.type = type;
      enemy.level = level;
      enemy.health = 20 + (level * 10); // Base health scaling
      enemy.maxHealth = enemy.health;
      enemy.damage = 5 + (level * 2); // Base damage scaling
      enemy.state = 'idle';
      enemy.targetPosition = null;
      enemy.speed = 0.05;
      enemy.detectionRadius = 15;
      enemy.attackRadius = 2;
      enemy.attackCooldown = 0;
      enemy.maxAttackCooldown = 60; // frames (1 second)
      
      // Create model based on type
      switch(type) {
        case 'skeleton':
          createSkeletonModel(enemy);
          break;
        case 'bat':
          createBatModel(enemy);
          break;
        case 'snake':
          createSnakeModel(enemy);
          break;
        case 'vampire':
          createVampireModel(enemy);
          break;
        default:
          // Default enemy model
          const geometry = new THREE.BoxGeometry(1, 2, 1);
          const material = new THREE.MeshStandardMaterial({ color: 0x880000 });
          const model = new THREE.Mesh(geometry, material);
          model.castShadow = true;
          model.receiveShadow = true;
          enemy.add(model);
      }
      
      scene.add(enemy);
      enemies.push(enemy);
      return enemy;
    }
    
    // Create skeleton model
    function createSkeletonModel(enemy) {
      // Body
      const bodyGeometry = new THREE.BoxGeometry(0.7, 1.2, 0.4);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xe0e0e0,
        roughness: 0.9,
        metalness: 0.1
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1.2;
      body.castShadow = true;
      enemy.add(body);
      
      // Skull
      const skullGeometry = new THREE.SphereGeometry(0.4, 8, 8);
      const skull = new THREE.Mesh(skullGeometry, bodyMaterial);
      skull.position.y = 2.1;
      skull.castShadow = true;
      enemy.add(skull);
      
      // Arms
      const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
      leftArm.position.set(-0.45, 1.3, 0);
      leftArm.castShadow = true;
      enemy.add(leftArm);
      enemy.leftArm = leftArm;
      
      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
      rightArm.position.set(0.45, 1.3, 0);
      rightArm.castShadow = true;
      enemy.add(rightArm);
      enemy.rightArm = rightArm;
      
      // Legs
      const legGeometry = new THREE.BoxGeometry(0.3, 0.9, 0.3);
      
      const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      leftLeg.position.set(-0.2, 0.45, 0);
      leftLeg.castShadow = true;
      enemy.add(leftLeg);
      enemy.leftLeg = leftLeg;
      
      const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      rightLeg.position.set(0.2, 0.45, 0);
      rightLeg.castShadow = true;
      enemy.add(rightLeg);
      enemy.rightLeg = rightLeg;
    }
    
    // Create bat model
    function createBatModel(enemy) {
      // Body
      const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.7,
        metalness: 0.2
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 2;
      body.castShadow = true;
      enemy.add(body);
      
      // Wings
      const wingGeometry = new THREE.PlaneGeometry(1.5, 0.8);
      const wingMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8,
        metalness: 0.1,
        side: THREE.DoubleSide
      });
      
      const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
      leftWing.position.set(-0.8, 2, 0);
      leftWing.rotation.z = Math.PI / 6;
      leftWing.castShadow = true;
      enemy.add(leftWing);
      enemy.leftWing = leftWing;
      
      const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
      rightWing.position.set(0.8, 2, 0);
      rightWing.rotation.z = -Math.PI / 6;
      rightWing.castShadow = true;
      enemy.add(rightWing);
      enemy.rightWing = rightWing;
      
      // Eyes
      const eyeGeometry = new THREE.SphereGeometry(0.1, 6, 6);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.5
      });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.2, 2, 0.4);
      enemy.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.2, 2, 0.4);
      enemy.add(rightEye);
    }
    
    // Create snake model
    function createSnakeModel(enemy) {
      // Snake body segments
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x008800,
        roughness: 0.7,
        metalness: 0.3
      });
      
      const segments = 6;
      enemy.bodySegments = [];
      
      for (let i = 0; i < segments; i++) {
        const size = 0.3 - (i * 0.02);
        const segmentGeometry = new THREE.SphereGeometry(size, 8, 8);
        const segment = new THREE.Mesh(segmentGeometry, bodyMaterial);
        
        // Position segments in a curved line
        const angle = (i / (segments - 1)) * Math.PI * 0.5;
        segment.position.x = Math.sin(angle) * i * 0.3;
        segment.position.z = Math.cos(angle) * i * 0.3;
        segment.position.y = 0.3;
        
        segment.castShadow = true;
        enemy.add(segment);
        enemy.bodySegments.push(segment);
      }
      
      // Snake head
      const headGeometry = new THREE.ConeGeometry(0.4, 0.8, 8);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0x006600,
        roughness: 0.7,
        metalness: 0.3
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.rotation.x = Math.PI / 2;
      head.position.copy(enemy.bodySegments[0].position);
      head.position.z += 0.4;
      head.castShadow = true;
      enemy.add(head);
      enemy.head = head;
      
      // Eyes
      const eyeGeometry = new THREE.SphereGeometry(0.1, 6, 6);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffff00,
        emissive: 0xffff00,
        emissiveIntensity: 0.5
      });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.15, 0.15, 0.2);
      head.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.15, 0.15, 0.2);
      head.add(rightEye);
    }
    
    // Create vampire model
    function createVampireModel(enemy) {
      // Body
      const bodyGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.5);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        roughness: 0.7,
        metalness: 0.3
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1.4;
      body.castShadow = true;
      enemy.add(body);
      
      // Cape
      const capeGeometry = new THREE.PlaneGeometry(1.4, 1.8);
      const capeMaterial = new THREE.MeshStandardMaterial({
        color: 0x880000,
        roughness: 0.7,
        metalness: 0.2,
        side: THREE.DoubleSide
      });
      const cape = new THREE.Mesh(capeGeometry, capeMaterial);
      cape.position.set(0, 1.4, -0.3);
      cape.castShadow = true;
      enemy.add(cape);
      enemy.cape = cape;
      
      // Head
      const headGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xf0d0d0,
        roughness: 0.7,
        metalness: 0.1
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 2.5;
      head.castShadow = true;
      enemy.add(head);
      
      // Eyes
      const eyeGeometry = new THREE.SphereGeometry(0.1, 6, 6);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8
      });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.2, 2.5, 0.35);
      enemy.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.2, 2.5, 0.35);
      enemy.add(rightEye);
      
      // Arms
      const armGeometry = new THREE.BoxGeometry(0.25, 1.2, 0.25);
      
      const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
      leftArm.position.set(-0.55, 1.5, 0);
      leftArm.castShadow = true;
      enemy.add(leftArm);
      enemy.leftArm = leftArm;
      
      const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
      rightArm.position.set(0.55, 1.5, 0);
      rightArm.castShadow = true;
      enemy.add(rightArm);
      enemy.rightArm = rightArm;
      
      // Legs
      const legGeometry = new THREE.BoxGeometry(0.35, 1, 0.35);
      
      const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      leftLeg.position.set(-0.25, 0.5, 0);
      leftLeg.castShadow = true;
      enemy.add(leftLeg);
      
      const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
      rightLeg.position.set(0.25, 0.5, 0);
      rightLeg.castShadow = true;
      enemy.add(rightLeg);
    }
    
    // Add other player to scene
    function addOtherPlayer(playerData) {
      // Create other player
      const otherPlayer = new THREE.Group();
      
      // Body
      const geometry = new THREE.BoxGeometry(0.6, 1.7, 0.6);
      const material = new THREE.MeshStandardMaterial({ color: 0xff5555 });
      const body = new THREE.Mesh(geometry, material);
      body.position.y = 0.85;
      body.castShadow = true;
      body.receiveShadow = true;
      otherPlayer.add(body);
      
      // Head
      const headGeometry = new THREE.SphereGeometry(0.35, 8, 8);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0xffddbb,
        roughness: 0.7,
        metalness: 0.1
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 1.75;
      head.castShadow = true;
      otherPlayer.add(head);
      
      // Nametag
      const nameTag = document.createElement('div');
      nameTag.className = 'player-name';
      nameTag.textContent = playerData.id;
      nameTag.style.position = 'absolute';
      nameTag.style.width = '100px';
      nameTag.style.textAlign = 'center';
      nameTag.style.color = 'white';
      nameTag.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
      nameTag.style.padding = '2px 5px';
      nameTag.style.borderRadius = '3px';
      nameTag.style.fontSize = '12px';
      nameTag.style.fontFamily = 'Arial, sans-serif';
      nameTag.style.pointerEvents = 'none';
      document.body.appendChild(nameTag);
      
      // Position the player
      otherPlayer.position.set(playerData.x, playerData.y, playerData.z);
      otherPlayer.rotation.y = playerData.rotationY;
      
      // Add to scene
      scene.add(otherPlayer);
      
      // Store reference
      otherPlayers[playerData.id] = {
        model: otherPlayer,
        nameTag: nameTag
      };
      
      addCombatMessage(`${playerData.id} has joined the game.`);
    }
    
    // Update other player
    function updateOtherPlayer(playerData) {
      if (otherPlayers[playerData.id]) {
        const otherPlayer = otherPlayers[playerData.id].model;
        
        // Update position and rotation
        otherPlayer.position.x = playerData.x;
        otherPlayer.position.y = playerData.y;
        otherPlayer.position.z = playerData.z;
        otherPlayer.rotation.y = playerData.rotationY;
      }
    }
    
    // Remove other player
    function removeOtherPlayer(playerId) {
      if (otherPlayers[playerId]) {
        // Remove from scene
        scene.remove(otherPlayers[playerId].model);
        
        // Remove nametag
        if (otherPlayers[playerId].nameTag.parentNode) {
          otherPlayers[playerId].nameTag.parentNode.removeChild(otherPlayers[playerId].nameTag);
        }
        
        // Remove from collection
        delete otherPlayers[playerId];
        
        addCombatMessage(`${playerId} has left the game.`);
      }
    }
    
    // Setup input listeners
    function setupEventListeners() {
      // Keyboard events for movement
      window.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          keys[e.code] = true;
        }
        
        // Attack on space
        if (e.code === 'Space') {
          playerAttack();
        }
      });
      
      window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          keys[e.code] = false;
        }
      });
      
      // Window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Socket events
      socket.on('currentPlayers', (players) => {
        Object.keys(players).forEach((id) => {
          if (id === socket.id) {
            // Update our player position
            player.position.x = players[id].x;
            player.position.y = players[id].y;
            player.position.z = players[id].z;
            player.rotation.y = players[id].rotationY;
          } else {
            addOtherPlayer(players[id]);
          }
        });
        
        // Update camera target
        controls.target.copy(player.position);
        controls.target.y = player.position.y + 1;
        controls.update();
        
        // Check region
        checkPlayerRegion();
      });
      
      socket.on('newPlayer', (playerData) => {
        addOtherPlayer(playerData);
      });
      
      socket.on('playerMoved', (playerData) => {
        updateOtherPlayer(playerData);
      });
      
      socket.on('playerDisconnected', (playerId) => {
        removeOtherPlayer(playerId);
      });
      
      socket.on('chat', (data) => {
        addCombatMessage(`${data.id}: ${data.message}`);
      });
      
      socket.on('systemMessage', (message) => {
        addCombatMessage(message);
      });
    }
    
    // Setup UI elements
    function setupUI() {
      // Initialize minimap
      updateMinimap();
      updatePlayerStats();
    }
    
    // Player attack function
    function playerAttack() {
      if (player.attackCooldown <= 0) {
        // Start attack animation
        player.attackCooldown = player.maxAttackCooldown;
        player.sword.visible = true;
        
        // Check for enemies in range
        const attackRange = 2;
        let hitEnemy = false;
        
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          const distance = player.position.distanceTo(enemy.position);
          
          if (distance <= attackRange) {
            // Check if enemy is in front of player
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
            const toEnemy = new THREE.Vector3()
              .subVectors(enemy.position, player.position)
              .normalize();
            
            const dot = forward.dot(toEnemy);
            if (dot > 0.5) { // Enemy is within ~60 degree cone in front
              hitEnemy = true;
              
              // Apply damage to enemy
              enemy.health -= playerStats.attackDamage;
              
              // Show damage number
              showDamageNumber(enemy.position.clone().add(new THREE.Vector3(0, 1.5, 0)), playerStats.attackDamage);
              
              // Add combat message
              addCombatMessage(`You hit the ${enemy.type} for ${playerStats.attackDamage} damage.`);
              
              // Flash enemy red
              flashObject(enemy, 0xff0000);
              
              // Check if enemy is dead
              if (enemy.health <= 0) {
                // Calculate XP based on enemy level
                const xpGained = enemy.level * 10;
                
                // Gain XP
                gainExperience(xpGained);
                
                // Show XP number
                showDamageNumber(enemy.position.clone().add(new THREE.Vector3(0, 2, 0)), xpGained, 'xp');
                
                // Add combat message
                addCombatMessage(`You defeated the ${enemy.type} and gained ${xpGained} XP.`);
                
                // Remove enemy
                scene.remove(enemy);
                enemies.splice(i, 1);
                
                // Respawn enemy after delay
                setTimeout(() => {
                  if (activeRegion && activeRegion.type === 'combat') {
                    spawnEnemiesInRegion(activeRegion);
                  }
                }, 5000);
              }
            }
          }
        }
        
        if (!hitEnemy) {
          addCombatMessage("Your attack missed.");
        }
      }
    }
    
    // Show damage or xp number
    function showDamageNumber(position, amount, type = 'damage') {
      // Create element
      const element = document.createElement('div');
      element.style.position = 'absolute';
      element.style.fontFamily = 'Arial, sans-serif';
      element.style.fontWeight = 'bold';
      element.style.fontSize = '16px';
      element.style.textShadow = '2px 2px 0 #000';
      element.style.pointerEvents = 'none';
      element.style.zIndex = '1000';
      
      // Set text based on type
      if (type === 'damage') {
        element.textContent = `-${amount}`;
        element.style.color = '#ff6666';
      } else if (type === 'heal') {
        element.textContent = `+${amount}`;
        element.style.color = '#66ff66';
      } else if (type === 'xp') {
        element.textContent = `+${amount} XP`;
        element.style.color = '#9933ff';
      }
      
      // Convert 3D position to screen position
      const screenPos = worldToScreen(position);
      element.style.left = screenPos.x + 'px';
      element.style.top = screenPos.y + 'px';
      
      // Add to DOM
      document.body.appendChild(element);
      
      // Animate and remove
      setTimeout(() => {
        element.style.transition = 'all 1s ease-out';
        element.style.opacity = '0';
        element.style.transform = 'translateY(-30px)';
        
        setTimeout(() => {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }, 1000);
      }, 10);
    }
    
    // Convert world position to screen coordinates
    function worldToScreen(position) {
      const vector = position.clone();
      vector.project(camera);
      
      return {
        x: (vector.x * 0.5 + 0.5) * window.innerWidth,
        y: (-vector.y * 0.5 + 0.5) * window.innerHeight
      };
    }
    
    // Flash object red (for damage) or other color
    function flashObject(object, color = 0xff0000) {
      const originalMaterials = [];
      
      // Store original materials
      object.traverse((child) => {
        if (child.isMesh && child.material) {
          originalMaterials.push({
            mesh: child,
            material: child.material
          });
          
          // Create flash material
          child.material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5
          });
        }
      });
      
      // Reset materials after delay
      setTimeout(() => {
        originalMaterials.forEach(item => {
          item.mesh.material = item.material;
        });
      }, 100);
    }
    
    // Add message to combat log
    function addCombatMessage(message) {
      const msgElement = document.createElement('div');
      msgElement.textContent = message;
      msgElement.style.marginBottom = '3px';
      
      const combatLog = document.getElementById('combat-log');
      combatLog.appendChild(msgElement);
      combatLog.scrollTop = combatLog.scrollHeight;
    }
    
    // Check what region the player is in
    function checkPlayerRegion() {
      let playerInRegion = null;
      
      // Check each region
      for (const region of regions) {
        const distance = player.position.distanceTo(region.position);
        if (distance < region.radius) {
          playerInRegion = region;
          break;
        }
      }
      
      // If region changed
      if (playerInRegion !== activeRegion) {
        // Clear enemies when leaving a region
        clearEnemies();
        
        // Set new active region
        activeRegion = playerInRegion;
        
        // Update UI with region info
        updateRegionInfo();
        
        // Spawn enemies if combat region
        if (activeRegion && activeRegion.type === 'combat') {
          spawnEnemiesInRegion(activeRegion);
        }
      }
    }
    
    // Clear all enemies
    function clearEnemies() {
      for (const enemy of enemies) {
        scene.remove(enemy);
      }
      enemies = [];
    }
    
    // Spawn enemies in a region
    function spawnEnemiesInRegion(region) {
      const enemyCount = Math.min(5, region.maxEnemies);
      
      for (let i = 0; i < enemyCount; i++) {
        // Calculate random position within region
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * (region.radius * 0.8);
        const x = region.position.x + Math.cos(angle) * distance;
        const z = region.position.z + Math.sin(angle) * distance;
        
        // Create enemy
        const position = new THREE.Vector3(x, 0, z);
        createEnemy(region.enemyType, region.enemyLevel, position);
      }
    }
    
    // Update region info display
    function updateRegionInfo() {
      const regionName = document.getElementById('region-name');
      const regionDescription = document.getElementById('region-description');
      const regionInfo = document.getElementById('region-info');
      
      if (activeRegion) {
        regionName.textContent = activeRegion.name;
        
        if (activeRegion.type === 'safe') {
          regionDescription.innerHTML = '<p>Safe Zone</p>';
        } else if (activeRegion.type === 'combat') {
          regionDescription.innerHTML = 
            `<p>Enemy Level: ${activeRegion.enemyLevel}</p>` +
            `<p>Enemy Type: ${capitalizeFirstLetter(activeRegion.enemyType)}</p>`;
        }
        
        regionInfo.style.opacity = '1';
        addCombatMessage(`Entering ${activeRegion.name}`);
      } else {
        regionInfo.style.opacity = '0';
      }
    }
    
    // Update minimap
    function updateMinimap() {
      const canvas = document.getElementById('minimap-canvas');
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw regions
      for (const region of regions) {
        // Different colors for regions
        switch (region.name) {
          case 'Town':
            ctx.fillStyle = '#999';
            break;
          case 'Cemetery':
            ctx.fillStyle = '#666';
            break;
          case 'Cave':
            ctx.fillStyle = '#874b12';
            break;
          case 'Field':
            ctx.fillStyle = '#9b8c4a';
            break;
          case 'Castle':
            ctx.fillStyle = '#444';
            break;
          default:
            ctx.fillStyle = '#333';
        }
        
        // Convert world coordinates to minimap coordinates
        const mapX = (region.position.x + 60) / 120 * canvas.width;
        const mapY = (region.position.z + 60) / 120 * canvas.height;
        const mapRadius = (region.radius / 120) * canvas.width;
        
        ctx.beginPath();
        ctx.arc(mapX, mapY, mapRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add region name
        ctx.fillStyle = '#fff';
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(region.name, mapX, mapY);
      }
      
      // Draw other players
      for (const id in otherPlayers) {
        const otherPlayer = otherPlayers[id].model;
        
        // Convert world coordinates to minimap coordinates
        const mapX = (otherPlayer.position.x + 60) / 120 * canvas.width;
        const mapY = (otherPlayer.position.z + 60) / 120 * canvas.height;
        
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(mapX, mapY, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw enemies
      for (const enemy of enemies) {
        // Convert world coordinates to minimap coordinates
        const mapX = (enemy.position.x + 60) / 120 * canvas.width;
        const mapY = (enemy.position.z + 60) / 120 * canvas.height;
        
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(mapX, mapY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw player
      const playerMapX = (player.position.x + 60) / 120 * canvas.width;
      const playerMapY = (player.position.z + 60) / 120 * canvas.height;
      
      ctx.fillStyle = '#00f';
      ctx.beginPath();
      ctx.arc(playerMapX, playerMapY, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw player direction
      const dirX = Math.sin(player.rotation.y) * 7;
      const dirY = Math.cos(player.rotation.y) * 7;
      
      ctx.strokeStyle = '#00f';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(playerMapX, playerMapY);
      ctx.lineTo(playerMapX + dirX, playerMapY - dirY);
      ctx.stroke();
    }
    
    // Update player stats UI
    function updatePlayerStats() {
      document.getElementById('player-level').textContent = playerStats.level;
      document.getElementById('player-health').textContent = playerStats.health;
      document.getElementById('player-max-health').textContent = playerStats.maxHealth;
      document.getElementById('player-xp').textContent = playerStats.experience;
      document.getElementById('player-max-xp').textContent = playerStats.experienceToNextLevel;
      
      // Update health bar
      const healthPercent = (playerStats.health / playerStats.maxHealth) * 100;
      const healthBar = document.getElementById('health-bar');
      healthBar.style.width = healthPercent + '%';
      
      // Change health bar color based on health
      if (healthPercent > 60) {
        healthBar.style.backgroundColor = '#00cc00'; // Green
      } else if (healthPercent > 30) {
        healthBar.style.backgroundColor = '#ffcc00'; // Yellow
      } else {
        healthBar.style.backgroundColor = '#cc0000'; // Red
      }
      
      // Update XP bar
      const xpPercent = (playerStats.experience / playerStats.experienceToNextLevel) * 100;
      document.getElementById('xp-bar').style.width = xpPercent + '%';
    }
    
    // Gain experience and handle leveling
    function gainExperience(amount) {
      playerStats.experience += amount;
      
      // Check for level up
      if (playerStats.experience >= playerStats.experienceToNextLevel) {
        // Level up
        playerStats.level++;
        playerStats.experience -= playerStats.experienceToNextLevel;
        playerStats.experienceToNextLevel = Math.floor(playerStats.experienceToNextLevel * 1.5);
        
        // Improve stats
        playerStats.maxHealth += 20;
        playerStats.health = playerStats.maxHealth;
        playerStats.attackDamage += 5;
        playerStats.defense += 2;
        
        // Show level up message
        showLevelUp();
      }
      
      // Update UI
      updatePlayerStats();
    }
    
    // Show level up notification
    function showLevelUp() {
      addCombatMessage(`LEVEL UP! You are now level ${playerStats.level}!`);
      addCombatMessage(`Your stats have increased: Health: ${playerStats.maxHealth}, Attack: ${playerStats.attackDamage}, Defense: ${playerStats.defense}`);
      
      // Flash player with purple color for level up
      flashObject(player, 0x9933ff);
    }
    
    // Update nametags for other players
    function updateNameTags() {
      for (const id in otherPlayers) {
        const otherPlayer = otherPlayers[id];
        const screenPos = worldToScreen(
          otherPlayer.model.position.clone().add(new THREE.Vector3(0, 2.2, 0))
        );
        
        otherPlayer.nameTag.style.left = (screenPos.x - 50) + 'px';
        otherPlayer.nameTag.style.top = screenPos.y + 'px';
      }
    }
    
    // Update enemy AI
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        
        if (enemy.health <= 0) continue;
        
        // Check distance to player
        const distanceToPlayer = enemy.position.distanceTo(player.position);
        
        if (distanceToPlayer < enemy.detectionRadius) {
          // Player detected, move toward player
          enemy.state = 'chase';
          enemy.targetPosition = player.position.clone();
          
          if (distanceToPlayer < enemy.attackRadius) {
            // Player within attack range
            enemy.state = 'attack';
            
            // Only attack when cooldown is 0
            if (enemy.attackCooldown <= 0) {
              // Reset attack cooldown
              enemy.attackCooldown = enemy.maxAttackCooldown;
              
              // Attack player
              playerTakeDamage(enemy.damage);
              
              // Show damage number
              showDamageNumber(
                player.position.clone().add(new THREE.Vector3(0, 1.5, 0)),
                enemy.damage
              );
              
              // Add combat message
              addCombatMessage(`The ${enemy.type} hit you for ${enemy.damage} damage.`);
            }
          }
        } else {
          // No player detection, idle or wander
          enemy.state = 'idle';
          
          // Random chance to start wandering
          if (Math.random() < 0.01 && !enemy.targetPosition) {
            enemy.state = 'wander';
            
            // Set a random target position within 10 units
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 10;
            enemy.targetPosition = new THREE.Vector3(
              enemy.position.x + Math.cos(angle) * distance,
              enemy.position.y,
              enemy.position.z + Math.sin(angle) * distance
            );
          }
        }
        
        // Update movement based on state
        if ((enemy.state === 'chase' || enemy.state === 'wander') && enemy.targetPosition) {
          const direction = new THREE.Vector3()
            .subVectors(enemy.targetPosition, enemy.position)
            .normalize();
          
          // Only move on xz plane
          direction.y = 0;
          
          // If close to target and wandering, clear target
          if (enemy.state === 'wander' && 
              enemy.position.distanceTo(enemy.targetPosition) < 1) {
            enemy.targetPosition = null;
          } else {
            // Move toward target
            enemy.position.add(direction.multiplyScalar(enemy.speed));
            
            // Face movement direction
            enemy.lookAt(
              enemy.position.x + direction.x,
              enemy.position.y,
              enemy.position.z + direction.z
            );
          }
        }
        
        // Update attack cooldown
        if (enemy.attackCooldown > 0) {
          enemy.attackCooldown--;
        }
        
        // Animate enemy based on type
        animateEnemy(enemy);
      }
    }
    
    // Player takes damage
    function playerTakeDamage(damage) {
      // Apply defense reduction
      const damageReduction = playerStats.defense / 100;
      const actualDamage = Math.max(1, Math.floor(damage * (1 - damageReduction)));
      
      playerStats.health = Math.max(0, playerStats.health - actualDamage);
      
      // Update UI
      updatePlayerStats();
      
      // Flash player red
      flashObject(player);
      
      // Check if player died
      if (playerStats.health <= 0) {
        playerDied();
      }
    }
    
    // Handle player death
    function playerDied() {
      // Respawn at town center
      player.position.set(0, 0, 0);
      
      // Update camera
      controls.target.copy(player.position);
      controls.target.y = player.position.y + 1;
      controls.update();
      
      // Restore half health
      playerStats.health = Math.floor(playerStats.maxHealth / 2);
      updatePlayerStats();
      
      // Death message
      addCombatMessage('You have died and respawned in town with 50% health.');
      
      // Check region
      checkPlayerRegion();
    }
    
    // Animate enemy based on type
    function animateEnemy(enemy) {
      const time = Date.now() * 0.005;
      
      switch(enemy.type) {
        case 'skeleton':
          if (enemy.leftArm && enemy.rightArm && enemy.leftLeg && enemy.rightLeg) {
            if (enemy.state === 'idle') {
              // Subtle idle animation
              enemy.leftArm.rotation.x = Math.sin(time * 0.5) * 0.1;
              enemy.rightArm.rotation.x = Math.sin(time * 0.5 + 0.5) * 0.1;
            } else if (enemy.state === 'chase' || enemy.state === 'wander') {
              // Walking animation
              enemy.leftArm.rotation.x = Math.sin(time * 2) * 0.5;
              enemy.rightArm.rotation.x = Math.sin(time * 2 + Math.PI) * 0.5;
              enemy.leftLeg.rotation.x = Math.sin(time * 2 + Math.PI) * 0.5;
              enemy.rightLeg.rotation.x = Math.sin(time * 2) * 0.5;
            } else if (enemy.state === 'attack') {
              // Attack animation
              const attackAnim = (enemy.attackCooldown / enemy.maxAttackCooldown);
              enemy.leftArm.rotation.x = -Math.PI / 2 + attackAnim * Math.PI / 2;
              enemy.rightArm.rotation.x = -Math.PI / 2 + attackAnim * Math.PI / 2;
            }
          }
          break;
          
        case 'bat':
          if (enemy.leftWing && enemy.rightWing) {
            // Wing flapping animation
            let wingFlap = Math.sin(time * 6) * 0.5;
            
            if (enemy.state === 'idle') {
              wingFlap *= 0.3; // Less flapping when idle
            }
            
            enemy.leftWing.rotation.z = Math.PI / 6 + wingFlap;
            enemy.rightWing.rotation.z = -Math.PI / 6 - wingFlap;
            
            // Hovering animation
            enemy.position.y = 2 + Math.sin(time) * 0.1;
          }
          break;
          
        case 'snake':
          if (enemy.bodySegments && enemy.bodySegments.length > 0) {
            // Slithering animation
            for (let i = 0; i < enemy.bodySegments.length; i++) {
              const segment = enemy.bodySegments[i];
              const offset = i * 0.2;
              
              segment.position.x = Math.sin(time * 2 + offset) * 0.2;
            }
            
            // Orient head to follow the first body segment
            if (enemy.head && enemy.bodySegments.length > 0) {
              enemy.head.position.copy(enemy.bodySegments[0].position);
              enemy.head.position.z += 0.4;
              
              // If chasing or attacking, raise the head
              if (enemy.state === 'chase' || enemy.state === 'attack') {
                enemy.head.position.y += 0.2 + Math.sin(time * 3) * 0.1;
              }
            }
          }
          break;
          
        case 'vampire':
          if (enemy.cape && enemy.leftArm && enemy.rightArm) {
            // Cape billowing
            enemy.cape.rotation.x = Math.sin(time) * 0.1;
            
            if (enemy.state === 'idle') {
              // Subtle idle animation
              enemy.leftArm.rotation.x = Math.sin(time * 0.5) * 0.1;
              enemy.rightArm.rotation.x = Math.sin(time * 0.5 + 0.5) * 0.1;
            } else if (enemy.state === 'chase' || enemy.state === 'wander') {
              // Walking animation
              enemy.leftArm.rotation.x = Math.sin(time * 2) * 0.2;
              enemy.rightArm.rotation.x = Math.sin(time * 2 + Math.PI) * 0.2;
            } else if (enemy.state === 'attack') {
              // Attack animation
              enemy.leftArm.rotation.x = -Math.PI / 4;
              enemy.rightArm.rotation.x = -Math.PI / 4;
              enemy.leftArm.rotation.z = Math.sin(time * 8) * 0.2 - 0.3;
              enemy.rightArm.rotation.z = Math.sin(time * 8) * 0.2 + 0.3;
            }
          }
          break;
      }
    }
    
    // Animate player
    function animatePlayer() {
      // Get movement direction
      const isMoving = keys.KeyW || keys.KeyA || keys.KeyS || keys.KeyD;
      
      // Animate limbs based on movement
      if (isMoving) {
        const time = Date.now() * 0.005;
        
        player.leftLeg.rotation.x = Math.sin(time * 2) * 0.5;
        player.rightLeg.rotation.x = Math.sin(time * 2 + Math.PI) * 0.5;
        player.leftArm.rotation.x = Math.sin(time * 2 + Math.PI) * 0.3;
        player.rightArm.rotation.x = Math.sin(time * 2) * 0.3;
      } else {
        // Reset limbs when not moving
        player.leftLeg.rotation.x = 0;
        player.rightLeg.rotation.x = 0;
        player.leftArm.rotation.x = 0;
        player.rightArm.rotation.x = 0;
      }
      
      // Update attack animation
      if (player.attackCooldown > 0) {
        player.attackCooldown--;
        
        // Attack animation
        if (player.sword.visible) {
          const progress = 1 - (player.attackCooldown / player.maxAttackCooldown);
          player.rightArm.rotation.x = -Math.PI / 2 + progress * Math.PI / 2;
          
          // Hide sword when attack finishes
          if (player.attackCooldown === 0) {
            player.sword.visible = false;
          }
        }
      }
    }
    
    // Capitalize first letter
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Update player movement
      const direction = new THREE.Vector3();
      const rotation = controls.getAzimuthalAngle();
      
      if (keys.KeyW) {
        direction.z -= Math.cos(rotation) * 0.1;
        direction.x -= Math.sin(rotation) * 0.1;
      }
      if (keys.KeyS) {
        direction.z += Math.cos(rotation) * 0.1;
        direction.x += Math.sin(rotation) * 0.1;
      }
      if (keys.KeyA) {
        direction.z += Math.sin(rotation) * 0.1;
        direction.x -= Math.cos(rotation) * 0.1;
      }
      if (keys.KeyD) {
        direction.z -= Math.sin(rotation) * 0.1;
        direction.x += Math.cos(rotation) * 0.1;
      }
      
      if (direction.length() > 0) {
        player.position.add(direction);
        player.rotation.y = rotation;
        
        // Update camera target
        controls.target.copy(player.position);
        controls.target.y = player.position.y + 1;
        
        // Send updated position to server
        socket.emit('playerMovement', {
          x: player.position.x,
          y: player.position.y,
          z: player.position.z,
          rotationY: player.rotation.y
        });
        
        // Check if we entered a new region
        checkPlayerRegion();
      }
      
      // Update player animations
      animatePlayer();
      
      // Update enemy AI
      updateEnemies();
      
      // Update nametags for other players
      updateNameTags();
      
      // Update minimap
      updateMinimap();
      
      // Update controls
      controls.update();
      
      // Render scene
      renderer.render(scene, camera);
    }
    
    // Start when DOM is ready
    document.addEventListener('DOMContentLoaded', initGame);
  </script>
</body>
</html>